{\rtf1\ansi\ansicpg1252\cocoartf1671
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red100\green56\blue32;\red255\green255\blue255;\red196\green26\blue22;
\red170\green13\blue145;\red0\green0\blue0;\red63\green110\blue116;\red46\green13\blue110;\red38\green71\blue75;
\red28\green0\blue207;}
{\*\expandedcolortbl;;\csgenericrgb\c39100\c22000\c12500;\cssrgb\c100000\c100000\c100000\cname textBackgroundColor;\csgenericrgb\c77000\c10200\c8600;
\csgenericrgb\c66500\c5200\c56900;\csgenericrgb\c0\c0\c0;\csgenericrgb\c24700\c43100\c45600;\csgenericrgb\c18100\c5200\c43100;\csgenericrgb\c14900\c27800\c29400;
\csgenericrgb\c11000\c0\c81000;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab543
\pard\tx543\pardeftab543\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \cb3 #include\cf4 <stdio.h>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <stdlib.h>
\f1\fs24 \cf0 \

\f0\fs22 \cf5 struct\cf6  Node;
\f1\fs24 \cf0 \

\f0\fs22 \cf5 typedef\cf6  \cf5 struct\cf6  \cf7 Node\cf6  * PtrToNode;
\f1\fs24 \cf0 \

\f0\fs22 \cf5 typedef\cf6  \cf7 PtrToNode\cf6  List;
\f1\fs24 \cf0 \

\f0\fs22 \cf5 typedef\cf6  \cf7 PtrToNode\cf6  Position;
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 struct\cf6  Node
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 int\cf6  e;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf7 Position\cf6  next;
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \};
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 void\cf6  Insert(\cf5 int\cf6  x, \cf7 List\cf6  l, \cf7 Position\cf6  p)
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf7 Position\cf6  TmpCell;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     TmpCell = (\cf5 struct\cf6  \cf7 Node\cf6 *) \cf8 malloc\cf6 (\cf5 sizeof\cf6 (\cf5 struct\cf6  \cf7 Node\cf6 ));
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6 (TmpCell == \cf5 NULL\cf6 )
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf8 printf\cf6 (\cf4 "Memory out of space\\n"\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 else
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         TmpCell->\cf7 e\cf6  = x;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         TmpCell->\cf7 next\cf6  = p->\cf7 next\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         p->\cf7 next\cf6  = TmpCell;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\
\

\f0\fs22 \cf5 int\cf6  isLast(\cf7 Position\cf6  p, \cf7 List\cf6  l)
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 return\cf6  (p->\cf7 next\cf6  == l);
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\

\f0\fs22 \cf7 Position\cf6  FindPrevious(\cf5 int\cf6  x, \cf7 List\cf6  l)
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf7 Position\cf6  p = l;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 while\cf6 (p->\cf7 next\cf6  != l && p->\cf7 next\cf6 ->\cf7 e\cf6  != x)
\f1\fs24 \cf0 \

\f0\fs22 \cf6         p = p->\cf7 next\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 return\cf6  p;
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\

\f0\fs22 \cf7 Position\cf6  Find(\cf5 int\cf6  x, \cf7 List\cf6  l)
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf7 Position\cf6  p = l->\cf7 next\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 while\cf6 (p != l && p->\cf7 e\cf6  != x)
\f1\fs24 \cf0 \

\f0\fs22 \cf6         p = p->\cf7 next\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 return\cf6  p;
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 void\cf6  Delete(\cf5 int\cf6  x, \cf7 List\cf6  l)
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf7 Position\cf6  p, TmpCell;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     p = \cf9 FindPrevious\cf6 (x, l);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6 (!\cf9 isLast\cf6 (p, l))
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         TmpCell = p->\cf7 next\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         p->\cf7 next\cf6  = TmpCell->\cf7 next\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf8 free\cf6 (TmpCell);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 else
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf8 printf\cf6 (\cf4 "Element does not exist!!!\\n"\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 void\cf6  Display(\cf7 List\cf6  l)
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf8 printf\cf6 (\cf4 "The list element are :: "\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf7 Position\cf6  p = l->\cf7 next\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 while\cf6 (p != l)
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf8 printf\cf6 (\cf4 "%d -> "\cf6 , p->\cf7 e\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6         p = p->\cf7 next\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 \ulth \ulc5 v\ulnone oid\cf6  main()
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 int\cf6  x, pos, ch, i;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf7 List\cf6  l;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     l = (\cf5 struct\cf6  \cf7 Node\cf6  *) \cf8 malloc\cf6 (\cf5 sizeof\cf6 (\cf5 struct\cf6  \cf7 Node\cf6 ));
\f1\fs24 \cf0 \

\f0\fs22 \cf6     l->\cf7 next\cf6  = l;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf7 List\cf6  p = l;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf8 printf\cf6 (\cf4 "CIRCULAR LINKED LIST IMPLEMENTATION OF LIST ADT\\n\\n"\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 do
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf8 printf\cf6 (\cf4 "\\n\\n1. INSERT\\t 2. DELETE\\t 3. FIND\\t 4. PRINT\\t 5. QUIT\\n\\nEnter the choice :: "\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf8 scanf\cf6 (\cf4 "%d"\cf6 , &ch);
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 switch\cf6 (ch)
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6             \cf5 case\cf6  \cf10 1\cf6 :
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 p = l;
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf8 printf\cf6 (\cf4 "Enter the element to be inserted :: "\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf8 scanf\cf6 (\cf4 "%d"\cf6 ,&x);
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf8 printf\cf6 (\cf4 "Enter the position of the element :: "\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf8 scanf\cf6 (\cf4 "%d"\cf6 ,&pos);
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf5 for\cf6 (i = \cf10 1\cf6 ; i < pos; i++)
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6                     p = p->\cf7 next\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf9 Insert\cf6 (x,l,p);
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf5 break\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 
\f1\fs24 \cf0 \

\f0\fs22 \cf6             \cf5 case\cf6  \cf10 2\cf6 :
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 p = l;
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf8 printf\cf6 (\cf4 "Enter the element to be deleted :: "\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf8 scanf\cf6 (\cf4 "%d"\cf6 ,&x);
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf9 Delete\cf6 (x,p);
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf5 break\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 
\f1\fs24 \cf0 \

\f0\fs22 \cf6             \cf5 case\cf6  \cf10 3\cf6 :
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 p = l;
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf8 printf\cf6 (\cf4 "Enter the element to be searched :: "\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf8 scanf\cf6 (\cf4 "%d"\cf6 ,&x);
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 p = \cf9 Find\cf6 (x,p);
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf5 if\cf6 (p == l)
\f1\fs24 \cf0 \

\f0\fs22 \cf6                     \cf8 printf\cf6 (\cf4 "Element does not exist!!!\\n"\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf5 else
\f1\fs24 \cf0 \

\f0\fs22 \cf6                     \cf8 printf\cf6 (\cf4 "Element exist!!!\\n"\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf5 break\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 
\f1\fs24 \cf0 \

\f0\fs22 \cf6             \cf5 case\cf6  \cf10 4\cf6 :
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf9 Display\cf6 (l);
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf5 break\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}\cf5 while\cf6 (ch<\cf10 5\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6     
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
}